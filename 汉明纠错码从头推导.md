
 1.汉明纠错码从头推导

  看了很多资料，对汉明码要么只有计算方式讲解，要么
  对原理的讲解感觉隔靴搔痒，什么二分法，控制各个bit分组什么的，总觉得少了点什么。
  学一个东西，如果能了解这到底是怎么被发现发明
  的过程，那对他的理解就会更深刻。而不是一上来就一
  堆公式理论，没有意思。我只是从个人角度重新发现汉明校验码，而不代表汉明本人发明的过程。
  

  普通的奇偶校验是奇偶校验，是对数据本身的01进行校
  验并且只能检测出1位的错误而且不能纠错。
  而汉明纠错码实际上是对bit的[索引][下标][序号]
  进行校验
  最多能纠正1个bit错误，最多能检测出2位bit不能修正

  好，现在我们从头开始发现校验码的过程
  有一串bit，比如10100111010，需要从A发送给B,但是传
  输过程中可能有某个bit反转：由0变1或由1变0。
  我们可以依次给这个二进制bit的每一位进行编号,
  
  [图.a]
+----+----+----+----+----+----+----+----+----+----+----+
| 1  | 0  | 1  | 0  | 0  | 1  | 1  | 1  | 0  | 1  | 0  |
+----+----+----+----+----+----+----+----+----+----+----+
|0001|0010|0011|0100|0101|0110|0111|1000|1001|1010|1011|
+----+----+----+----+----+----+----+----+----+----+----+
| 1  | 0  | 3  | 0  | 0  | 6  | 7  | 8  | 0  | 10 | 0  |
+----+----+----+----+----+----+----+----+----+----+----+

我们可以给1或者0所在位置进行编号,在知道数据长度的
前提下，给0或者1的位置进行编号其实都一样：给0编号
那么其余的位置就是1，给1编号其余位置就是0。接下来
我们逐步看到底是怎么依靠下标来进行纠错的。

(1) 假设我们传输一些各不相同的数据: a,b,c,d...从A到B
,中间可能出现差错，就是丢失了某1个数据（也有可能多了
某个数据）：或a或b等，B怎
么知道到底丢失或增加了哪1个数据呢？

对于普通的加法，a+b+c+d+e...+r=s,我们可以把s当做这
一组数据的校验码一起发送。接收方收到a,b,c,d,e...,r,s，
当然可能有某个数据丢失了(先不考虑校验码s丢失),之后
计算接受到的这组数据的和：a+b+c...+r=s'，那么用s-s'
就能得到这1个丢失（s'-s 得到的是增加的数字）的数据
了。 如果abcde等表示数据bit为1或0的下标，那么就可
以检测出来到底是哪个bit出错了
 例如假如图a所示:A传输1,3,6,7,8,10,35(35是校验码)给B。B在收到数
 据后 依次相加，发现数据之和s'等于27，那么能推断
 出丢失了8的索引数据,。因为s=35，减去s'=27等于8。

(2) 接下来从二进制角度考虑这个问题：
先熟悉一下无进位的二进制加法：
  00010110
+ 01110011
-----------
  01100101

  那么无借位的二进制减法:
  00010110
- 01110011
-----------
  01100101
其实这也是二进制的异或(xor)操作。
所以加一个数n和减一个数n结果是一样的
 
3)对于没有重复的二进制序列相加而言如图1：
    图 1               图 2
    0010               0010
    0011               0011
    0101     --->     
    1000               1000
    1010               1010
    1110               1110
---------            ------
  s=1000             s=1000
              相加 (s'=1101)
 
 观察尝试后发现，任意1个数字的丢失最后都会反应到最
 后结果的和s上面
现在A从图1发送数据0010，0011...,1110,1000(总和s) 给B,假设只有0101丢失，B把所有除了s的结果相加得到s'=1101，
用收到的1000(s)减去1101，得到0101，就是丢失的数字。
也就是说对于二进制的不进位加法（异或）而言上面
的操作仍然适用。

好，接下来我们看一个有趣的现象，注意了。
当最后的s恰好等于0000时候：
    ....          ....   
    xxxx   --->        
    ....          .... 
---------     ---------
  s=0000       s'=xxxx
我们二进制加法最后得到的s'恰好等于xxxx。就是说a+b+c...+r的结果直接就等于丢失的数字。其实是因为异或操作
的加上一个数字和减去一个数字是相同的效果。
举例来看更直观:
  0010             0010    0010     0010    0010 
  0011     0011            0011     0011    0011 
  1001     1001    1001             1001    1001 
  1010     1010    1010    1010             1010 
  1100     1100    1100    1100     1100         
  1110     1110    1110    1110     1110    1110 
-------  ------- ------- -------  ------- -------
s=0000  s'=0010 s'=0011 s'=1001  s'=1010 s'=1100 
上图第一列是所有值相加等于0000，右边5列依次是丢失一
个值之后的和s'，都依次等于丢失的值。

4)我们知道用校验和s可以找到丢失的数字，那么现在还有
一个问题就是s如果丢失怎么办?
如果我们约定好s是一个固定的数值，比如是0000，那就不
需要担心s丢失的问题了，因为A根本就不必传送s给B。

然而对于任意个不同的二进制数的和我们无法保证最后得
到肯定是0000。

但是，换个角度，我们可以在某些特殊位置插入我们构造
的数字，来使得最后所有位置索引的校验和满足0000。
提取数据的时候再忽略这些特殊位置的值，因为他们不
是我们要使用的数据。
  0000
  0001  <-- 保留 a(0或1)
  0010  <-- 保留 b(0或1)
  0011 
  0100  <-- 保留 c(0或1)
  0101
  0110
  0111
  1000  <-- 保留 d(0或1)
  1001 
  1010 
  1011
  1100 
  1101
  1110 
  1111
-------

我们把只有2^0,2^1,2^2,2^3...的位置当做保留位。其余
数据位(3,5,6,7,9,10...等非2^n的位置）上如果为bit1，
就把相应位置索引对应二进制相加，得到对数据各个
bit索引的和s=abcd。要使校验和最终等于0000，那么
保留位2^0,2^1,2^2,2^3位置就分别为a,b,c,d，使得最
后校验和等于0000:
 abcd
+abcd
-----
=0000

根据上面的认知，起始校验和都是0000那么如果1位数据出
错的话所得的校验和就等于出错的位置。并且还有一个附
带的效果就是校验位本身出错的话也会又校验和指出！想
想还是很神奇，一个参与校验和的来调整自身是0还是1的
位置本身也能被自己参与的校验和指出来自己是否出错。

上面的情况是属于丢失了一个位置索引，也就是1变0，可以检测出来。
如果是多计算进来了一个索引，也就是0变1，那么相当于
最后的结果上有加上了这个索引的值，也可以正常纠错。

下面是一个编码和解码的例子：
编码:
假设有10个bit长度的数据需要校验：1110000101
我们先计算对于m个bit到底需校验位bit数n是多少：
因为第0位的索引是0000..对最后的和没有任何影响，
所以不能使它，就少了1位。
那么就是2^n-1 >= n+m
所以n=4。15 >=4+10
开始计算海明码的abcd
 示意图如下
+----+----+----+----+
|0000|0001|0010|0011|
| x  | a  | b  | 1  |
+----+----+----+----+
|0100|0101|0110|0111|
| c  | 1  | 1  | 0  |
+----+----+----+----+
|1000|1001|1010|1011|
| d  | 0  | 0  | 1  |
+----+----+----+----+
|1100|1101|1110|1111|
| 1  | 0  | 1  |    |
+----+----+----+----+

        0011
        0101
        0110
        1011
        1100
      + 1110
      ------
        1001
依次对应dcba
所以最后生成的是
   a b 1 c 1 1 0 d 0 0 1 1 0 1

 把dcba分别替换成计算出来的1001，得到：
   1 0 1 0 1 1 0 1 0 0 1 1 0 1

解码：
 把各个bit的下标进行相加（异或），全为0则无错，
 否则得到的是出错的那1位bit

  0001
  0011
  0101
  0110
  1000
  1011
  1100
  1110
------
  0000
说明没有出错

////////////////////汉明码go语言演示代码（仅仅是示意和演示，不能真正用来校验）///////////////////////////
package main

import (
	"fmt"
	"math"
)

func xor(a []int, b []int) []int {
	if len(a) < len(b) {
		a, b = b, a
	}
	result := make([]int, len(a))
	lena := copy(result, a)
	lenb := len(b)
	fmt.Println("inner::", result)
	for i := 1; i <= len(b); i++ {
		bit_a := a[lena-i]
		bit_b := b[lenb-i]
		if bit_a != 0 {
			bit_a = 1
		}
		if bit_b != 0 {
			bit_b = 1
		}
		if bit_a != bit_b {
			result[lena-i] = 1
		} else {
			result[lena-i] = 0
		}
	}
	return result
}

func needCorrectBitSize(dataBitLen int) int {
	n := 2 //least is 2
	//2**n - 1 >= n + m
	for ; (int(math.Pow(2, float64(n))) - 1) < (n + dataBitLen); n++ {
	}
	return n
}

func encode(bits []int) []int {
	fmt.Println("argument:", bits)
	m := len(bits)
	n := needCorrectBitSize(m)
	//编码后的bit数组最后+1因为第0位没使用
	encodedBits := make([]int, m+n+1)
	for i := 0; i < len(encodedBits); i++ {
		encodedBits[i] = -i * 10
	}
	fmt.Println(encodedBits)
	finalXOR := 0
	to := 3 //从3开始因为1和2是2**0和2**1
	for from := 0; from < m; from++ {
		v := bits[from]
		//skip n position which is 2**n
		if 0 == (to-1)&to {
			fmt.Print("to is:", to)
			encodedBits[to] = -1
			to = to + 1
		}
		if v != 0 {
			finalXOR = finalXOR ^ to
		}
		fmt.Println("to ", to, encodedBits[to])
		encodedBits[to] = v
		to += 1
	}
	//put finalXor's bits to result
	for i := 0; i < n; i++ {
		encodedBits[1<<i] = (finalXOR >> i) & 1
	}
	fmt.Println("finalXOR:", finalXOR)
	fmt.Println("encodedBits:", encodedBits)
	return encodedBits
}

var arr = [][]int{{}, {}, {}, {}}

func main() {
	a := []int{1, 0, 1, 0, 1, 0}
	b := []int{1, 1, 1, 0, 0, 0, 1}
	c := xor(a, b)
	//fmt.Println(a)
	//fmt.Println(b)
	fmt.Println(c)
	encode(a)
}
